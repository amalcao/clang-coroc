//===--- RewriteCoroC.cpp - Playground for the code rewriter ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Hacks and fun related to the code rewriter.
//
//===----------------------------------------------------------------------===//

#include "clang/Rewrite/Frontend/ASTConsumers.h"
#include "clang/AST/AST.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/Attr.h"
#include "clang/AST/ParentMap.h"
#include "clang/Basic/CharInfo.h"
#include "clang/Basic/Diagnostic.h"
#include "clang/Basic/IdentifierTable.h"
#include "clang/Basic/SourceManager.h"
#include "clang/Lex/Lexer.h"
#include "clang/Rewrite/Frontend/Rewriters.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "llvm/ADT/DenseSet.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/raw_ostream.h"
#include <vector>
#include <iostream>
#include <sstream>
#include <memory>

using namespace clang;
using llvm::utostr;

namespace {
  /// \brief Thunk helper function for Spawn Operator
  class ThunkHelper {
    ASTContext *Context;
    Rewriter &Rewrite;

    CallExpr *TheCallExpr;
    std::string ThunkUID;
    bool hasDump;
  
    void dumpThunkStruct(std::ostream& OS);
    void dumpThunkFunc(std::ostream& OS);

  public:
    ThunkHelper(ASTContext *C, Rewriter &R, 
                CallExpr *CE, std::string UID) 
      : Context(C), Rewrite(R)
      , TheCallExpr(CE), ThunkUID(UID), hasDump(false) { }
    
    bool MatchCallExpr(CallExpr *CE);

    void DumpThunkCallPrologue(std::ostream& OS,
                               CallExpr* CE, 
                               std::string paramName);
    
    void GetFuncName(std::string& funcName);
    void GetStructName(std::string& structName);

    bool HasDump() { return hasDump; }

    void Dump(std::ostream& OS) {
      if (!hasDump) {
        OS << "\n/// auto generated by CoroC rewriter.\n";
        dumpThunkStruct(OS);
        dumpThunkFunc(OS);
        OS << "\n/// end\n\n";
        hasDump = true;
      }
    }
  };

  /// \brief Recursive visit everything in AST, and make the translation.
  class CoroCRecursiveASTVisitor 
      : public RecursiveASTVisitor<CoroCRecursiveASTVisitor> 
  {
    static long unique_id_generator;

    bool hasMain;

    Rewriter &Rewrite;
    ASTContext *Context;
    std::vector<ThunkHelper*> ThunkPool; 

    Token getNextTok(SourceLocation CurLoc);
    SourceLocation getNextTokLocStart(SourceLocation CurLoc);
    ThunkHelper *getOrCreateThunkHelper(CallExpr *C);
	bool rewriteCoroCRefTy(Expr *E);

  public:
    CoroCRecursiveASTVisitor(Rewriter &R, ASTContext *C) 
      : Rewrite(R), Context(C), hasMain(false) { }

    ~CoroCRecursiveASTVisitor();
 
    void DumpThunkHelpers(std::ostream&);
     
	bool VisitValueDecl(ValueDecl *D);
    bool VisitFunctionDecl(FunctionDecl *D);

    bool VisitCoroCSpawnCallExpr(CoroCSpawnCallExpr *E);
    bool VisitCoroCMakeChanExpr(CoroCMakeChanExpr *E);
    bool VisitCoroCYieldStmt(CoroCYieldStmt *S);
    bool VisitCoroCQuitStmt(CoroCQuitStmt *S);
    
	bool VisitArraySubscriptExpr(ArraySubscriptExpr *E);
    bool VisitDeclRefExpr(DeclRefExpr *E);
    bool VisitMemberExpr(MemberExpr *E);

	Expr *VisitBinaryOperator(BinaryOperator *B);

    bool HasMain() { return hasMain; }
  };

  /// \brief 
  class RewriteCoroC : public ASTConsumer {
    DiagnosticsEngine &Diags;
    const LangOptions &LangOpts;
    ASTContext *Context;
    SourceManager *SM;
    std::string InFileName;
    raw_ostream* OutFile;
    CoroCRecursiveASTVisitor *Visitor;

    Rewriter Rewrite;
    
  public:

    void Initialize(ASTContext &context) override;

    // Top Level Driver code.
    bool HandleTopLevelDecl(DeclGroupRef D) override; 
    void HandleTopLevelSingleDecl(Decl *D);
    void HandleDeclInMainFile(Decl *D);
    RewriteCoroC(const std::string &inFile, raw_ostream *OS,
                DiagnosticsEngine &D, const LangOptions &LOpts);

    ~RewriteCoroC() { 
      if (Visitor != nullptr) 
        delete Visitor; 
    }

    void HandleTranslationUnit(ASTContext &C) override;

  };
}

/// Match if the current thunk is suitable for the given CallExpr
bool ThunkHelper::MatchCallExpr(CallExpr *CE) {
  if (!TheCallExpr || !CE) return false;
  // compare the two names, that methord works for C env
  return Rewrite.ConvertToString(TheCallExpr->getCallee()) ==
            Rewrite.ConvertToString(CE->getCallee());
}

/// Get the name of the thunk helper function
void ThunkHelper::GetFuncName(std::string &funcName) {
  funcName = "__thunk_helper_";
  funcName += ThunkUID;
}

/// Get the typename of the thunk helper's param 
void ThunkHelper::GetStructName(std::string &structName) {
  structName = "__thunk_struct_";
  structName += ThunkUID;
}

/// Dump the thunk calling code into the OS
void ThunkHelper::DumpThunkCallPrologue(std::ostream &OS, 
                                        CallExpr *CE,
                                        std::string paramName) {
  // If the func call without any arg, ignore it!
  if (CE->getNumArgs() == 0) return;
  
  OS << "\n\tstruct __thunk_struct_" << ThunkUID 
     << "*  " << paramName << " = (" 
     << "struct __thunk_struct_" << ThunkUID
     << "*)::malloc(sizeof("
     << "struct __thunk_struct_" << ThunkUID << "));\n\t";
  
  // Init each arg
  int i = 0;
  CallExpr::arg_iterator it = CE->arg_begin();
  for (; it != CE->arg_end(); ++it) {
    OS << paramName << "->_param" << i++ << " = ";
    
    Expr *E = *it;
    QualType Ty = E->getType();

    if (Ty == Context->ChanRefTy ||
        Ty == Context->TaskRefTy) {
      OS << "__refcnt_get(*" 
         << Rewrite.ConvertToString(E) << ")";
    } else
      OS << Rewrite.ConvertToString(E);

    OS << ";\n\t";
  }
}

/// Dump the thunk param struct's body
void ThunkHelper::dumpThunkStruct(std::ostream &OS) {
  if (TheCallExpr->getNumArgs() == 0) return;

  OS << "\nstruct __thunk_struct_" 
     << ThunkUID << " { \n";

  int i = 0;
  CallExpr::arg_iterator it = TheCallExpr->arg_begin();
  for (; it != TheCallExpr->arg_end(); ++it) {
    OS << "\t" << (*it)->getType().getAsString()
       << " _param" << i++ << ";\n";
  }
  OS << "};\n"; 
}

/// Dump the thunk function defination
void ThunkHelper::dumpThunkFunc(std::ostream &OS) {
  unsigned numArgs = TheCallExpr->getNumArgs();
  Expr *E = TheCallExpr->getCallee();

  // Generate the func declaration:
  OS << "\nint __thunk_helper_"
     << ThunkUID << "(";

  if (numArgs == 0)
    OS << "void*";
  else
    OS << "struct __thunk_struct_" << ThunkUID << " *";
  
  OS << "_arg) {\n\t";
  
  // Generate the func body:

  // 1. callee's declaration
  FunctionDecl *FD = TheCallExpr->getDirectCallee();
  OS << FD->getReturnType().getAsString() << " ";
  OS << Rewrite.ConvertToString(E) << "(";
  
  for (unsigned i = 0; i < numArgs; ++i) {
    QualType Ty = FD->getParamDecl(i)->getOriginalType();
    if (Ty == Context->ChanRefTy || Ty == Context->TaskRefTy)
      OS << "__CXX_refcnt_t<" << Ty.getAsString() << " >";
    else
      OS << Ty.getAsString();
    
    if (i < numArgs - 1)
      OS << ", ";
  }

  OS << ");\n\t";


  // 2. calling the thunk helper function
  OS << Rewrite.ConvertToString(E) << "(";

  std::vector<int> ArgStk;
  if (numArgs > 0) {
    int i = 0;
    CallExpr::arg_iterator it = TheCallExpr->arg_begin();
    for (;;) {
      QualType Ty = (*it)->getType();
      if (Ty == Context->ChanRefTy || Ty == Context->TaskRefTy)
        ArgStk.push_back(i);

      OS << "_arg->_param" << i++;
      if (++it == TheCallExpr->arg_end()) break;
      OS << ", ";
    }
  }

  OS << ");\n\t";
  
  // 3. release the auto-references if any exisit
  for (int k = 0; k < ArgStk.size(); ++k) {
    OS << "__refcnt_put(_arg->_param" << ArgStk[k] << ");\n\t";
  }

  // 4. release the _arg and quit
  if (numArgs > 0)
    OS << "::free(_arg);\n\t";
  OS << "__CoroC_Quit(0);\n}\n";
}

/// The static item of the CoroCRecursiveASTVisitor 
long CoroCRecursiveASTVisitor::unique_id_generator = 0;

/// The destructor of the CoroCRecursiveASTVisitor
CoroCRecursiveASTVisitor::~CoroCRecursiveASTVisitor() {
  std::vector<ThunkHelper*>::iterator it = ThunkPool.begin();
  for (; it != ThunkPool.end(); ++it) 
    delete (*it);
}

/// Get and return the next token after the one in current location
Token CoroCRecursiveASTVisitor::getNextTok(SourceLocation CurLoc) {
  int offset = Lexer::MeasureTokenLength(CurLoc, 
                                         Rewrite.getSourceMgr(),
                                         Rewrite.getLangOpts());
  
  Token TheTok;
  assert (!Lexer::getRawToken(CurLoc.getLocWithOffset(offset), 
                              TheTok,
                              Rewrite.getSourceMgr(),
                              Rewrite.getLangOpts(),
                              true));
  return TheTok;  
}

/// Get the next token after the one in current location
/// and return the source location of that token.
SourceLocation CoroCRecursiveASTVisitor::getNextTokLocStart(SourceLocation CurLoc) {
  Token TheTok = getNextTok(CurLoc);
  return TheTok.getLocation();
}

/// Dump all thunk helpers' code if neccessary..
void CoroCRecursiveASTVisitor::DumpThunkHelpers(std::ostream &OS) {
  std::vector<ThunkHelper*>::iterator it = ThunkPool.begin();
  for (; it != ThunkPool.end(); ++it)
    (*it)->Dump(OS);
}

/// Get or Create a thunk helper for CoroC Spawn Call
ThunkHelper* CoroCRecursiveASTVisitor::getOrCreateThunkHelper(CallExpr *C) {
  std::vector<ThunkHelper*>::iterator it = ThunkPool.begin();
  for (; it != ThunkPool.end(); ++it) {
    if ((*it)->MatchCallExpr(C))
      return (*it);
  }

  std::stringstream SS;
  SS << unique_id_generator++;

  ThunkHelper *Thunk = 
    new ThunkHelper(Context, Rewrite, C, SS.str());

  ThunkPool.push_back(Thunk);
  return Thunk;
}

/// Visit the FunctionDecl, change the `main' to `__CoroC_UserMain'
bool CoroCRecursiveASTVisitor::VisitFunctionDecl(FunctionDecl *D) {
  if (D->getDeclName()) {
    if (D->getNameAsString() == "main") {
      SourceLocation SL = D->getNameInfo().getLoc();
      Rewrite.ReplaceText(SL, 4, "__CoroC_UserMain");
      hasMain = true;
    }
  }

  return true;
}

#if 0
/// Override the VarDecl when the var is a CoroC refcnt type
bool CoroCRecursiveASTVisitor::VisitVarDecl(VarDecl *D) {
#else
/// Override the ValueDecl when the type is CoroC Ref
bool CoroCRecursiveASTVisitor::VisitValueDecl(ValueDecl *D) {
#endif
  // Determine the type of the var
  QualType Ty = D->getType();
  if (Ty->isArrayType())
    Ty = Context->getBaseElementType(Ty);

  if (Ty == Context->TaskRefTy ||
      Ty == Context->ChanRefTy) {
    SourceLocation StartLoc = D->getSourceRange().getBegin();

    // Check if the `__chan_t' with a type attribute
    Token TheTok = getNextTok(StartLoc);
    if (TheTok.getKind() == tok::less) {
      while (TheTok.getKind() != tok::greater) {
        SourceLocation Loc = TheTok.getLocation();
        TheTok = getNextTok(Loc);
        Rewrite.ReplaceText(Loc, "");
      }
      Rewrite.ReplaceText(TheTok.getLocation(), ""); // delete the '>'
    }

    Rewrite.InsertText(StartLoc, "__CXX_refcnt_t<");
    Rewrite.InsertTextAfterToken(StartLoc, " >");
  }
  return true;
}


/// Find and fix the ChanRef & TaskRef if they are as the array elements
bool CoroCRecursiveASTVisitor::rewriteCoroCRefTy(Expr *E) {
  // Determine the type of the ref
  QualType Ty = E->getType();
  if (Ty == Context->TaskRefTy || Ty == Context->ChanRefTy)  {
    if (!E->isLValue()) {
      Rewrite.InsertText(E->getLocStart(), "*(");
	  Rewrite.InsertTextAfterToken(E->getLocEnd(), ")");
	}
  }
  return true;
}

/// Find and fix the ChanRef & TaskRef if they are as the array elements
bool CoroCRecursiveASTVisitor::VisitArraySubscriptExpr(ArraySubscriptExpr *E) {
  return rewriteCoroCRefTy(E);
}

/// Find and fix the ChanRef & TaskRef if they are as the struct / union members
bool CoroCRecursiveASTVisitor::VisitMemberExpr(MemberExpr *E) {
  return rewriteCoroCRefTy(E);
}

/// Find and fix the ChanRef & TaskRef
bool CoroCRecursiveASTVisitor::VisitDeclRefExpr(DeclRefExpr *E) {
  return rewriteCoroCRefTy(E);
}

/// Override the BinaryOperator when it is a CoroC channel operation
Expr *CoroCRecursiveASTVisitor::VisitBinaryOperator(BinaryOperator *B) {
  // Determine the type of this binary operator
  unsigned Opc = B->getOpcode();

  if (Opc != BO_Shl && Opc != BO_Shr) 
    return B;
  
  // Check if the channel operator..
  Expr *LHS = B->getLHS();
  Expr *RHS = B->getRHS();

  if (LHS->getType() == Context->ChanRefTy) {
    // Insert the function call at the start of the first expr
    Rewrite.InsertText(LHS->getLocStart(),
      Opc == BO_Shl ? "__CoroC_Chan_Send(" : "__CoroC_Chan_Recv(", true);
  
    // Replace the operator "<<" or ">>" with ","
    Rewrite.ReplaceText(B->getOperatorLoc(),
                      B->getOpcodeStr().size(), ",");
  
    // The second param should be a pointer for runtime calls
    // FIXME: Check if the RHS is a L-Value for address operation!!
    if (Opc == BO_Shl) {
      Rewrite.InsertTextAfterToken(RHS->getLocEnd(), ")");
    } else {
      Rewrite.InsertText(RHS->getExprLoc(), "&(");
      Rewrite.InsertTextAfterToken(RHS->getLocEnd(), "))");
    }
  }

  return B;
}

/// Transform the __CoroC_Spawn keyword
bool CoroCRecursiveASTVisitor::VisitCoroCSpawnCallExpr(CoroCSpawnCallExpr *E) {
  CallExpr *CE = E->getCallExpr();
  int numArgs = CE->getNumArgs();
  bool noThunk = false;
  
  if (numArgs == 1) {
    Expr *Arg = CE->getArg(0);
    noThunk = Arg->getType().getTypePtr()->isPointerType();
  }
    
  if (noThunk) {
    Expr *Callee = CE->getCallee();
    // Transform to runtime call:
    //  __CoroC_Spawn( (__CoroC_spawn_handler_t)func, param );
    Rewrite.InsertTextAfterToken(E->getLocEnd(), 
                               "((__CoroC_spawn_handler_t)");

    SourceLocation Loc = getNextTokLocStart(Callee->getLocEnd());
    Rewrite.ReplaceText(Loc, 1, ", ");
  
  } else {
    // struct __thunk_struct_xxx Px = { ... };
    //  __CoroC_Spawn( __thunk_helper_xxx, Px );
    
    // generate a random unique temp name
    std::stringstream paramName;
    paramName << "__coroc_temp_" << unique_id_generator++;

    // get or create a new thunker
    ThunkHelper *Thunk = getOrCreateThunkHelper(CE);
    std::stringstream SS;

    if (numArgs != 0) SS << "\n\t{";

    Thunk->DumpThunkCallPrologue(SS, CE, paramName.str());
    
    // insert the prologue before the __CoroC_Spawn keyword
    Rewrite.InsertText(E->getInsertLoc(), SS.str());
    
    // replace all the CE's text ..
    std::string funcName;
    Thunk->GetFuncName(funcName);
    std::stringstream SS1;
    SS1 << "((__CoroC_spawn_handler_t)" << funcName << ", ";
    
    if (CE->getNumArgs() == 0)
      SS1 << "NULL); \n\t";
    else
      SS1 << paramName.str() << "); \n\t}"; 
    
    // delete the ';' in nextline
    SourceLocation Loc = getNextTokLocStart(CE->getLocEnd());
    Rewrite.ReplaceText(Loc, 1, "");

    // replace the text 
    Rewrite.ReplaceText(CE->getSourceRange(), SS1.str()); 

    // stop to traverse the CallExpr since it has been replaced
    E->setCallExpr(nullptr);
  }

  return true;
}

/// Transform the __CoroC_Chan keyword
bool CoroCRecursiveASTVisitor::VisitCoroCMakeChanExpr(CoroCMakeChanExpr *E) {
  Expr *CE = E->getCapExpr();

  // Transform to runtime call:
  //  __CoroC_Chan(sizeof type, (expr));

  // replace '<' to '('
  SourceLocation Loc = getNextTokLocStart(E->getLocEnd());
  Rewrite.ReplaceText(Loc, 1, "(sizeof(");

  // insert '>' before the ',' or '>'
  Token Tok;
  do {
    Tok = getNextTok(Loc);
    Loc = Tok.getLocation();
  } while (Tok.isNot(tok::comma) && Tok.isNot(tok::greater));

  Rewrite.InsertText(Loc, ")");
  Rewrite.ReplaceText(E->getGTLoc(), 1, 
      CE != nullptr ? ")" : ", 0)"); // replace '>' to ')'

  return true;
}

/// Transform the __CoroC_Quit keyword
bool CoroCRecursiveASTVisitor::VisitCoroCQuitStmt(CoroCQuitStmt *S) {
  Expr *RE = S->getReturnExpr();
  
  if (RE == nullptr) {
    Rewrite.InsertTextAfterToken(S->getLocEnd(), "(0)");
  } else {
    Rewrite.InsertTextAfterToken(S->getLocEnd(), "(");
    Rewrite.InsertTextAfterToken(RE->getLocEnd(), ")");
  }
  return true;
}

/// Transform the __CoroC_Yield keyword
bool CoroCRecursiveASTVisitor::VisitCoroCYieldStmt(CoroCYieldStmt *S) {
  Rewrite.InsertTextAfterToken(S->getLocEnd(), "()");
  return true;
}


RewriteCoroC::RewriteCoroC(const std::string &inFile, raw_ostream* OS,
                           DiagnosticsEngine &D, const LangOptions &LOpt) 
                           : Diags(D), LangOpts(LOpt) 
                           , InFileName(inFile), OutFile(OS)
                           , Visitor(nullptr) {
  // TODO
}

void RewriteCoroC::Initialize(ASTContext &C) {
  Context = &C;
  SM = &C.getSourceManager();
  Rewrite.setSourceMgr(C.getSourceManager(), C.getLangOpts());
  Visitor = new CoroCRecursiveASTVisitor(Rewrite, Context);
}

bool RewriteCoroC::HandleTopLevelDecl(DeclGroupRef D) {
  typedef DeclGroupRef::iterator iter;

  for (iter I = D.begin(); I != D.end(); ++I) {
    Visitor->TraverseDecl(*I);  
    // Dump the thunk helpers if any exisit
    std::stringstream SS;
    Visitor->DumpThunkHelpers(SS);
    Rewrite.InsertText((*I)->getSourceRange().getBegin(), SS.str());
  }

  return true;
}

void RewriteCoroC::HandleTranslationUnit(ASTContext &C) {
  // print the new file buffer ..
  (*OutFile) << "/* C++ source file auto generated by Clang CoroC rewriter. */\n";
  (*OutFile) << "#include <stdlib.h>\n";
  (*OutFile) << "#include <libcoroc.h>\n";
  (*OutFile) << "#include <__CXX_refcnt_t.hpp>\n\n";

  const RewriteBuffer *RewriteBuf =
    Rewrite.getRewriteBufferFor(SM->getMainFileID());
  (*OutFile) << std::string(RewriteBuf->begin(), RewriteBuf->end());

  // generate the wrapper call to __CoroC_UserMain
  if (Visitor->HasMain()) {
    (*OutFile) << "\n/* wrapper call to __CoroC_UserMain */\n";
    (*OutFile) << "extern \"C\" {\n";
    (*OutFile) << "\tint user_main(int argc, char **argv) {\n\t";
    (*OutFile) << "\t__CoroC_UserMain(argc, argv);\n\t";
    (*OutFile) << "\treturn 0;\n\t}\n";
    (*OutFile) << "}\n/* end of the wrapper call */\n";
  }
}

ASTConsumer *clang::CreateCoroCRewriter(const std::string &InFile,
                                 raw_ostream *OS,
                                 DiagnosticsEngine &Diags,
                                 const LangOptions &LOpts) {
  return new RewriteCoroC(InFile, OS, Diags, LOpts);
}

